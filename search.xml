<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MPI notes</title>
      <link href="/2023/04/05/2023_mpi/"/>
      <url>/2023/04/05/2023_mpi/</url>
      
        <content type="html"><![CDATA[<h1 id="Crash-MPI"><a href="#Crash-MPI" class="headerlink" title="Crash MPI"></a>Crash MPI</h1><p>Following are basically the note when I went through <a href="https://www.hlrs.de/training/self-study-materials">https://www.hlrs.de/training/self-study-materials</a>. This tutorial is highly recommended as it contains plenty of informative code exercises!</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="Sequential-vs-Parallel"><a href="#Sequential-vs-Parallel" class="headerlink" title="Sequential vs Parallel"></a>Sequential vs Parallel</h3><p>Sequential - One memory, one processor; all the works done in linear order</p><p>Parallel - Many memories, many processors; at different levels, processors may share the memory / communicate via MPI (Socket - Node - Cluster)</p><h3 id="SPMD"><a href="#SPMD" class="headerlink" title="SPMD"></a>SPMD</h3><p>mingle (sub-)program, multiple data </p><p>MPMD (multiple program, multiple data) can be implemented with ranks.</p><h3 id="rank-in-MPI"><a href="#rank-in-MPI" class="headerlink" title="rank in MPI"></a>rank in MPI</h3><p>the rank of each processor determines the behavior / role in the program</p><h3 id="First-MPI-example"><a href="#First-MPI-example" class="headerlink" title="First MPI example"></a>First MPI example</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"></span><br><span class="line"><span class="comment"># application-related data</span></span><br><span class="line">n = <span class="literal">None</span></span><br><span class="line">result = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">comm_world = MPI.COMM_WORLD</span><br><span class="line"><span class="comment"># MPI-related data</span></span><br><span class="line">my_rank = comm_world.Get_rank() <span class="comment"># or my_rank = MPI.COMM_WORLD.Get_rank()</span></span><br><span class="line">num_procs = comm_world.Get_size() <span class="comment"># or ditto ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (my_rank == <span class="number">0</span>):</span><br><span class="line">   <span class="comment"># reading the application data "n" from stdin only by process 0:</span></span><br><span class="line">   n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">"Enter the number of elements (n): "</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># broadcasting the content of variable "n" in process 0 </span></span><br><span class="line"><span class="comment"># into variables "n" in all other processes:</span></span><br><span class="line">n = comm_world.bcast(n, root=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># doing some application work in each process, e.g.:</span></span><br><span class="line">result = <span class="number">1.0</span> * my_rank * n</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"I am process <span class="subst">{my_rank}</span> out of <span class="subst">{num_procs}</span> handling the <span class="subst">{my_rank}</span>ith part of n=<span class="subst">{n}</span> elements, result=<span class="subst">{result}</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (my_rank != <span class="number">0</span>):</span><br><span class="line">   <span class="comment"># sending some results from all processes (except 0) to process 0:</span></span><br><span class="line">   comm_world.send(result, dest=<span class="number">0</span>, tag=<span class="number">99</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="comment"># receiving all these messages and, e.g., printing them </span></span><br><span class="line">   rank = <span class="literal">None</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">f"I'm proc 0: My own result is <span class="subst">{result}</span>"</span>) </span><br><span class="line">   <span class="keyword">for</span> rank <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,num_procs):</span><br><span class="line">      result = comm_world.recv(source=rank, tag=<span class="number">99</span>)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">f"I'm proc 0: received result of process <span class="subst">{rank}</span> is <span class="subst">{result}</span>"</span>)</span><br></pre></td></tr></tbody></table></figure><p>Execution with <code>mpirun -np 4 python first-example.py</code> ; the output is</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Enter the number of elements (n): 100</span><br><span class="line">I am process 1 out of 4 handling the 1ith part of n=100 elements, result=100.0</span><br><span class="line">I am process 2 out of 4 handling the 2ith part of n=100 elements, result=200.0</span><br><span class="line">I am process 3 out of 4 handling the 3ith part of n=100 elements, result=300.0</span><br><span class="line">I am process 0 out of 4 handling the 0ith part of n=100 elements, result=0.0</span><br><span class="line">I'm proc 0: My own result is 0.0</span><br><span class="line">I'm proc 0: received result of process 1 is 100.0</span><br><span class="line">I'm proc 0: received result of process 2 is 200.0</span><br><span class="line">I'm proc 0: received result of process 3 is 300.0</span><br></pre></td></tr></tbody></table></figure><h3 id="Bottom-lines"><a href="#Bottom-lines" class="headerlink" title="Bottom lines"></a>Bottom lines</h3><ol><li>The output of each process is in the well defined sequence of its program</li><li>The output from different processes can be intermixed in any sequence</li><li>A sub-program needs to be connected to a message passing system</li><li>The total program (i.e., all sub-programs of the program) must be started with the MPI startup tool</li></ol><h3 id="Messages-among-processors"><a href="#Messages-among-processors" class="headerlink" title="Messages among processors"></a>Messages among processors</h3><ul><li>process id (rank)</li><li>location (sender / reciever)</li><li>Data type (sender / reciever)</li><li>Data size (sender / reciever)</li></ul><h3 id="P2P-Communication"><a href="#P2P-Communication" class="headerlink" title="P2P Communication"></a>P2P Communication</h3><p>From one processor to another;</p><p>Two types: synchronous / asynchronous (buffered)</p><h4 id="Synchronous-send"><a href="#Synchronous-send" class="headerlink" title="Synchronous send"></a>Synchronous send</h4><p>Both sender and reciever works at the same time; sender recieved an info when finished;</p><p>This operation blocks sender until the receive is posted; receive operation blocks until message was sent</p><h4 id="Asynchronous-send"><a href="#Asynchronous-send" class="headerlink" title="Asynchronous send"></a>Asynchronous send</h4><p>Sender puts the data in the buffer and know nothing about if received</p><h3 id="Blocking-x2F-Nonblocking"><a href="#Blocking-x2F-Nonblocking" class="headerlink" title="Blocking / Nonblocking"></a>Blocking / Nonblocking</h3><p>Some operations may block until another process acts;</p><p>Non-block: returns immediately, allows the subprocess to continue the work</p><p><strong>All nonblocking procedures must have a matching wait (or test) procedure.</strong></p><h3 id="Amdahl’s-Law"><a href="#Amdahl’s-Law" class="headerlink" title="Amdahl’s Law"></a>Amdahl’s Law</h3><p>Extra cost of parallel sets a limitation of speedup $\propto 1/f$</p><h2 id="Process-Model-and-Language-Bindings"><a href="#Process-Model-and-Language-Bindings" class="headerlink" title="Process Model and Language Bindings"></a>Process Model and Language Bindings</h2><h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br></pre></td></tr></tbody></table></figure><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">comm_world = MPI.COMM_WORLD</span><br><span class="line"></span><br><span class="line"><span class="comment"># Direct communication via numpy array</span></span><br><span class="line">comm_world.Send((snd_buf, ...), ...)</span><br><span class="line">comm_world.Recv((snd_buf, ...), ...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># object-serialization or packled</span></span><br><span class="line">comm_world.send(snd_buf, ...)</span><br><span class="line">rcv_buf = comm_world.recv(...)</span><br></pre></td></tr></tbody></table></figure><h3 id="Initialize"><a href="#Initialize" class="headerlink" title="Initialize"></a>Initialize</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"><span class="comment"># MPI.Init()</span></span><br><span class="line"><span class="comment"># no need as included in the import operation</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Finalize"><a href="#Finalize" class="headerlink" title="Finalize"></a>Finalize</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MPI.Finalize()</span></span><br><span class="line"><span class="comment"># no need as automatically called at the end of progran</span></span><br></pre></td></tr></tbody></table></figure><p>No more MPI call after this (including re-initialize)</p><h3 id="Start-MPI-program"><a href="#Start-MPI-program" class="headerlink" title="Start MPI program"></a>Start MPI program</h3><p>With either <code>mpirun</code> or <code>mpiexec</code>; the latter is recommended for standard reasons.</p><h3 id="MPI-COMM-WORLD"><a href="#MPI-COMM-WORLD" class="headerlink" title="MPI_COMM_WORLD"></a>MPI_COMM_WORLD</h3><p>This is a pre-defined handler for all the processes; each is assigned with a rank (0, 1, …, np - 1)</p><h3 id="Handles"><a href="#Handles" class="headerlink" title="Handles"></a>Handles</h3><p>Handles are the idenfication of MPI objects;</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># predefined constants</span></span><br><span class="line">MPI.COMM_WORLD</span><br><span class="line"></span><br><span class="line"><span class="comment"># value returned by MPI routines</span></span><br><span class="line">sub_comm = MPI.COMM_WORLD.Split(...)</span><br></pre></td></tr></tbody></table></figure><h3 id="Rank"><a href="#Rank" class="headerlink" title="Rank"></a>Rank</h3><p>Ranks are the identification of processes</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rank = comm.Get_rank()</span><br></pre></td></tr></tbody></table></figure><h3 id="Size"><a href="#Size" class="headerlink" title="Size"></a>Size</h3><p>Total number of processors in the communicator (= max(rank) + 1)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size = comm.Get_size()</span><br></pre></td></tr></tbody></table></figure><h3 id="is-Parallel-awesome"><a href="#is-Parallel-awesome" class="headerlink" title="is Parallel ! awesome"></a>is Parallel ! awesome</h3><p>We cannot guarantee the order of output, unless the processors can communicate ahead of output.</p><h2 id="Messages-and-Point-to-Point-Communication"><a href="#Messages-and-Point-to-Point-Communication" class="headerlink" title="Messages and Point-to-Point Communication"></a>Messages and Point-to-Point Communication</h2><h3 id="Messages-in-Python"><a href="#Messages-in-Python" class="headerlink" title="Messages in Python"></a>Messages in Python</h3><p>There are two ways of messaging in Python</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fast way, only for numpy</span></span><br><span class="line">comm_world.Send()</span><br><span class="line">comm_world.Recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Slow way, packled</span></span><br><span class="line">comm_world.send()</span><br><span class="line">comm_world.recv()</span><br></pre></td></tr></tbody></table></figure><h3 id="Sending"><a href="#Sending" class="headerlink" title="Sending"></a>Sending</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">comm.Send(buf, <span class="built_in">int</span> dest, <span class="built_in">int</span> tag=<span class="number">0</span>)</span><br><span class="line">comm.send(obj, <span class="built_in">int</span> dest, <span class="built_in">int</span> tag=<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><p><code>buf</code> is a ndarry (or anything implement the Python buffer protocol) while <code>obj</code> can be any object;</p><p><code>dest</code> is the rank of the dest. processor;</p><p><code>tag</code> is a int with additional info from the sender (usually used to specify the data type)</p><h4 id="Various-sending"><a href="#Various-sending" class="headerlink" title="Various sending"></a>Various sending</h4><p><code>ssend</code> for synchronous send - Completes iff the receive has started</p><p><code>bsend</code> for buffered / async send - Always complete, need to specify the place of buffer</p><p><code>send</code> for standard send - Either buffered or synchronous, use interal buffer</p><p> <code>rsend</code> for ready send - Start only the receiver has been posted (?)</p><h4 id="Which-is-better"><a href="#Which-is-better" class="headerlink" title="Which is better?"></a>Which is better?</h4><p>Synchronous ones requires waiting — high latency but best bandwidth</p><p>Async ones — low latency but bad bandwidth</p><h3 id="Receiving"><a href="#Receiving" class="headerlink" title="Receiving"></a>Receiving</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">comm.Recv(buf, <span class="built_in">int</span> source=ANY_SOURCE, <span class="built_in">int</span> tag=ANY_TAG, Status status=<span class="literal">None</span>)</span><br><span class="line">obj = comm.recv(<span class="built_in">int</span> source=ANY_SOURCE, <span class="built_in">int</span> tag=ANY_TAG, Status status=<span class="literal">None</span>)</span><br></pre></td></tr></tbody></table></figure><p><code>buf</code> is the receive buffer;</p><p><code>source</code> is the rank of the src. processor;</p><p><code>tag</code> is still tag (tag must match!);</p><p>For Python, you need to match <code>Send</code>-<code>Recv</code> and <code>send</code>-<code>recv</code></p><h4 id="One-receiving"><a href="#One-receiving" class="headerlink" title="One receiving"></a>One receiving</h4><p><code>recv</code> can accpet all kind of <code>send</code> - Completes when a message arrived</p><h3 id="On-print-function-of-Python"><a href="#On-print-function-of-Python" class="headerlink" title="On print function of Python"></a>On <code>print</code> function of Python</h3><p>Following is the <code>pingpong</code> function:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"></span><br><span class="line">buffer = [ <span class="literal">None</span> ]</span><br><span class="line"></span><br><span class="line">comm_world = MPI.COMM_WORLD</span><br><span class="line">my_rank = comm_world.Get_rank()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (my_rank == <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"I am <span class="subst">{my_rank}</span> before send ping"</span>)</span><br><span class="line">    comm_world.send(buffer, dest=<span class="number">1</span>, tag=<span class="number">17</span>)</span><br><span class="line">    buf = comm_world.recv(source=<span class="number">1</span>, tag=<span class="number">17</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"I am <span class="subst">{my_rank}</span> after recv pong"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> (my_rank == <span class="number">1</span>):</span><br><span class="line">    buf = comm_world.recv(source=<span class="number">0</span>, tag=<span class="number">17</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"I am <span class="subst">{my_rank}</span> after  recv ping"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"I am <span class="subst">{my_rank}</span> before send pong"</span>)</span><br><span class="line">    comm_world.send(buf, dest=<span class="number">0</span>, tag=<span class="number">17</span>)</span><br></pre></td></tr></tbody></table></figure><p>My expectation output is</p> <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I am 0 before send ping</span><br><span class="line">I am 1 after  recv ping</span><br><span class="line">I am 1 before send pong</span><br><span class="line">I am 0 after recv pong</span><br></pre></td></tr></tbody></table></figure><p>Which demonstrates the order of send, recv operations; however, the real output is</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I am 1 after  recv ping</span><br><span class="line">I am 1 before send pong</span><br><span class="line">I am 0 before send ping</span><br><span class="line">I am 0 after recv pong</span><br></pre></td></tr></tbody></table></figure><p>This is actually due to the feature of <code>print </code> rather than MPI: if we add time info into the output, we have</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I am 1 after  recv ping 1680684130.3630078</span><br><span class="line">I am 1 before send pong 1680684130.363044</span><br><span class="line">I am 0 before send ping 1680684130.362919</span><br><span class="line">I am 0 after recv pong 1680684130.3631082</span><br></pre></td></tr></tbody></table></figure><p>Which means the order is #0 send -&gt; #1 recv -&gt; #1 send -&gt; #0 recv. So the flush is only emptied when finishing parallel.</p><h3 id="Dead-locks"><a href="#Dead-locks" class="headerlink" title="Dead locks"></a>Dead locks</h3><p>If Sync is used in send/recv, dead lock forms if two (or more) processors are waiting each other.</p><h3 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h3><p>These are info from src to dst; contains metadata of the communication</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">status.Get_source()</span><br><span class="line">status.Get_tag()</span><br><span class="line">status.Get_count()</span><br></pre></td></tr></tbody></table></figure><h3 id="Message-Order-Preservation"><a href="#Message-Order-Preservation" class="headerlink" title="Message Order Preservation"></a>Message Order Preservation</h3><p>One link one order</p>]]></content>
      
      
      
        <tags>
            
            <tag> Research, Computer Science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>年终总结</title>
      <link href="/2022/12/31/2022-summary/"/>
      <url>/2022/12/31/2022-summary/</url>
      
        <content type="html"><![CDATA[<p>我很少写年终总结，上次写（也是第一次写）是在初中的时候：那天上学时我刚刚从一场大病中恢复，早上到学校得知前一天的作业是写这样一份总结，才忙不迭问同学借了一张信纸随便胡诌了数条。那份东西和其他同学的一样被贴在教室后面的墙上，但是我没有（再敢）看过它一眼。（这里本来有一大段丧气话，但是我把它删掉了。）</p><p>今年对于许多人都不算太好过，对于我而言前两个月尤甚。那段时间我一直收到来自各种学校的邮件，当然无一例外是拒信。这当然是在为我前一年申请季的一系列错误买单：以为重金请来的留学中介能包揽一切，所以对于自己的申请完全无关心。申请季结束的时候，我甚至连一次面试机会也没有得到。必须承认，这段时间对我造成了沉重的精神伤害：作息紊乱也许还在其次，我感觉自己好像失去了对于新事物的热情，丧失了接纳理解以外事物的能力；并且 Imposter Syndrome （它可能真的存在！也就是说，我可能真的是 Imposter！）也随着拒信数量增加日益严重。后面的事情大家也许都知道：我（大概是侥幸）得到了东京大学的录取，然后把在科大的最后半年用来匆匆准备毕业论文、在最后几门研究生课上睡觉、狠狠咒骂自己一无所获的四年，然后离开。我脑海中留下唯一的印象是某个睡过头的早上，我突然领悟到（也许还有一些浅色床单之类的臆想）。之后就是所谓的 long vacation，开始自己 “真正的” 第一个科研课题，和朋友们玩很久，以及 quit 掉了本应最重要的日语课；但是我仍然感到夏日回忆是一种缺憾。最后这三个月是在日本度过的：我又一次作为新生坐在教室里，但是一种陌生感切断了我和四年前自己的联系。</p><p>今年的境地无疑放大了我习惯上的弱点。我一直在武断而非必要的压制自己的情绪，认为不带有哀伤的生活是有罪的；同时我总是预期事情会向着坏的方面发展，正是这种推演屡次把我拖入 panic attack；还有拖延——就连拖延影响到我的时间也被拖延本身影响了。</p><p>今年当然也不是毫无收获的一年。平安无事地从科大毕业自然是一件值得庆幸的事，除此之外免于 gap 也救了我一命。除此之外也不过是多去了某些地方、多玩了某些游戏，大抵如此。<!--说起来我好像遇到了重要的人，祝她在新的一年诸事顺利～--></p><p>拥有自由意志的人应该能自由地选择由环境或者遭遇加诸于他们的想法，甚至能在纷杂的思绪中基于理性取舍；从这个角度上讲我当然是不自由的——我只能做到与环境交互，并最终成为环境所塑造的人。退而求其次的话，我仍希望能由自己来掷骰子。对于新年的唯一期望就是变成阳キャ，不要再在犹豫和摇摆中错失机会了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入住两周，我治好了入户 Wifi 的精神内耗</title>
      <link href="/2022/10/15/20221015/"/>
      <url>/2022/10/15/20221015/</url>
      
        <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>事情要从来霓虹租房说起：</p><p>来这边的时候比较匆忙，直到走之前大概两周才开始考虑租房的事情。其时已经没什么选择的余地了，就在车站<del>附近</del>两公里开外找了一间公寓签了合同，中介是某レ〇〇〇ス。入住之后发现原来租房的钱里还附带了每个月大概三千円的网费，据中介网络大概是“一栋楼共用100兆宽带”，听着就让人血压升高。百闻不如一见，实际的情况恐怕要更加糟糕：在非高峰期浏览网页（比如<a href="https://speedtest.net/">这个</a>）都费劲，遑论在晚上要和一栋楼的设备竞争带宽，联机游戏完全属于奢望。搬进来的前几天里，我唯一的替代方案就是用流量开热点。<del>正值 Windows 22H2 推送，没多久就清空了我这个月的流量</del></p><p>说到这里要好好介绍一下这个月额三千円的宽带套餐：房屋中介（レ〇〇〇ス）兼有 ISP 的角色，网络也不是入户即用的而是要经过中介提供的终端（ラ〇〇〇〇〇〇ク）。这个终端实际上是一个定制化、集成无线热点功能的Android机顶盒，一边连着入户网线，另一面接着电视。使用的时候需要用中介提供的账号密码注册、开通网络，之后这个终端就会在电视上显示 SSID 和密码。在这个热点下的网络体验可想而知；同时出于可用性考虑终端大概还限制了网络的下行速度，只要开游戏就开始高延迟加丢包，对于想打游戏（指派派）的我而言基本等于没有。</p><p>为了能愉快的联机，我开始研究怎么保证网络稳定。考虑过的方案包括去学校（<strong>工作场所不宜</strong>） / 开流量卡（贵） / 拉其他运营商的线（语言不通，不能在房间里打洞），但是都有一定的困难；所以问题就回到了怎么好好利用这条包含在房租里的线路。</p><h3 id="回校代理"><a href="#回校代理" class="headerlink" title="回校代理"></a>回校代理</h3><p>很喜欢[数据删除]的一句话：一入〇〇门，一生〇〇人。作为刚刚从技校毕业的中级技工，一个没过期的回校代理是必不可少的。考虑到从霓虹回国的延迟，挂代理其实只有稳定性的考虑。但是这里感人的网络质量消解了任何的稳定性，游戏体验也只不过是从连不上变成能连接。</p><h3 id="加速器"><a href="#加速器" class="headerlink" title="加速器"></a>加速器</h3><p>打游戏不开加速器，就好像读四大名著不用 Kindle。遗憾的是，加速器也没用（<del>而且用的还是出国线路</del>）</p><h2 id="拔网线（物理）"><a href="#拔网线（物理）" class="headerlink" title="拔网线（物理）"></a>拔网线（物理）</h2><p>在极度愤怒的情况下，我决定把终端（ラ〇〇〇〇〇〇ク）上的网线直接接在电脑上。这时打开浏览器，发现内网地址 10.XXX.XXX.1 要求验证用户名和密码。把各种用户名和密码乱试一通均不成功，而直接留空会出现鉴权失败。就在这时，奇迹发生了：虽然浏览器提示验证失败，但多数网页（除了<a href="https://speedtest.net/">这个</a>）已经可以访问了，Steam 本身的更新也可以正常进行。另一方面，我发现 ping 任何网站的结果都为超时（但是地址可以解析），Steam上的多数游戏也无法连接到服务器。由于绕过了 ISP 的终端，与之相关的网速限制和丢包问题不复存在，网络的可用性有了很大提升，但是离联机 Apex 还有很大距离。<code>tracert</code> 的结果如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tracert vstc.edu.cn</span></span><br><span class="line"></span><br><span class="line">通过最多 30 个跃点跟踪</span><br><span class="line">到 vstc.edu.cn [202.38.64.246] 的路由:</span><br><span class="line"></span><br><span class="line">  1     1 ms     1 ms    &lt;1 毫秒 10.123.237.1</span><br><span class="line">  2     *        *       *</span><br><span class="line">  </span><br><span class="line">(下略)</span><br></pre></td></tr></tbody></table></figure><h3 id="回校代理-1"><a href="#回校代理-1" class="headerlink" title="回校代理"></a>回校代理</h3><p>结果上成功了。回校代理的运作基本正常，通过优化线路到服务器的延迟可以控制在 100ms 左右。在套上这层代理之后，ping 的结果也能正常显示，基本可以认为有了对网络的完整访问。对此的解释是网关 10.XXX.XXX.1 不会拦截加密流量，所以 HTTPS 网页可以访问，而 ICMP 包会被拦截；而回校代理加密了所有通信，所以 ping 恢复了正常。美中不足的是，在这种网络条件下连接 Apex 日本服务器需要回国再出国，延迟仍然是不可接受的 （&gt; 200ms）。</p><h3 id="加速器-1"><a href="#加速器-1" class="headerlink" title="加速器"></a>加速器</h3><p>打游戏不开加速器，就好像读四大名著不用 Kindle （二度）。在回校代理开启的前提下，由于加速器只能优化出国线路，效果有限，最终游戏内 ping 在 150ms 上下。如果关闭回校代理，加速器无法单独工作。</p><h3 id="Cloudflare-Warp"><a href="#Cloudflare-Warp" class="headerlink" title="Cloudflare Warp"></a>Cloudflare Warp</h3><p>按照加密流量的思路，我被推荐了 CF Warp。CF Warp的安装和配置并不困难，只要直接从<a href="https://1.1.1.1/">官网</a>上下好客户端，一路确定就可以用了。但是它并不奏效，没有像预期的那样工作。随后我尝试了用 Wire Guard 配置 CF Warp 代理，也无法工作。对此我猜测 CF Warp 和 WG （前者其实也基于后者的实现）与 Cisco AnyConnect 工作在不同的抽象层级上，所以抗封锁能力也不同。</p><h2 id="转变思路"><a href="#转变思路" class="headerlink" title="转变思路"></a>转变思路</h2><p>回顾上面的 <code>tracert</code> 结果，我发现我遇到的正是千千万万个（技校以外的）大学生在生活中遇到的实际问题：校园网鉴权。一些网络资源指出可以通过伪装 DNS 流量 / 伪装已验证设备 MAC 地址来绕过鉴权，出于成本考虑我首先尝试了后者。大多数教程使用了 <a href="https://www.advanced-port-scanner.com/">Advanced Port Scanner</a> 来扫描内网的设备，但是这个策略似乎只在无线网络上有效；乱扫一通之后发现的设备只有本机和网关本身，所以没有可用的 MAC 地址。最终的解决方案来自 ISP 提供的终端：由于它本质上是定制化的 AndroidTV，MAC 地址可以直接从设置得到，之后只要把插着网线的设备的硬件 MAC 地址换成上述地址即可。修改之后再打开浏览器已经不要求鉴权了，访问网页 / ping / 连接游戏服务器全部大成功，放两张图在下面：</p><img src="2022-10-15 23.28.17.jpg" style="zoom:100%;"><img src="2022-10-15 23.28.23.jpg" style="zoom:40%;"><p>这样还有一个好处就是不会和网络中的其他硬件有 MAC 地址冲突，<del>没有人受伤害的世界达成了</del></p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>接下来也许会买个路由器，因为目前电脑的无线网卡快要坏掉了。</p><ul><li>目前已经买到了路由器并且配了 MAC 地址克隆，全天候的完整互联网访问 get</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天文学中的物理过程</title>
      <link href="/2022/09/17/%E5%A4%A9%E6%96%87%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/09/17/%E5%A4%A9%E6%96%87%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是 <a href="https://campuspress.yale.edu/astro320/">Yale Astro320</a> 使用自编教材的翻译。课程本身是本科难度，需要的数学和物理技巧并不高深，可以作为天体物理流体力学之入门。本文尚在施工中，完工日期待定。</p><h2 id="第一章-流体与等离子体简介"><a href="#第一章-流体与等离子体简介" class="headerlink" title="第一章 流体与等离子体简介"></a>第一章 流体与等离子体简介</h2><h3 id="什么是流体？"><a href="#什么是流体？" class="headerlink" title="什么是流体？"></a>什么是流体？</h3><p>流体是一种可以流动、无定型、对外力响应很弱的物质。</p><ul><li>流体的组成粒子（原子、分子、离子甚至恒星）可以“自由”地在流体中移动</li><li>若流体不是自引力的，则它总是取其容器的形状</li><li>流体受外力时其形状以稳定的速率改变</li></ul><h3 id="什么是等离子体？"><a href="#什么是等离子体？" class="headerlink" title="什么是等离子体？"></a>什么是等离子体？</h3><p>等离子体的组成粒子是带电荷的，因而其相互作用是长程力。</p><h3 id="流体的分类"><a href="#流体的分类" class="headerlink" title="流体的分类"></a>流体的分类</h3><p>流体总是由大量的粒子组成，这些粒子可以是分子、原子、暗物质粒子甚至恒星。流体之间的差异主要体现在它们组成粒子的相互作用上，例子包括库仑力（等离子体中的带电粒子）、范德瓦尔斯力（中性流体中的分子）和引力（星系中的恒星）。流体可以是<strong>有碰撞的</strong>或者是<strong>无碰撞的</strong>，其中碰撞的定义是<em>两个组成粒子的相互作用使得至少一个粒子的轨迹有了明显偏转</em>。粒子间的碰撞使得流体趋向（局域）<strong>热力学平衡</strong>，并使流体粒子的物质分布趋向<strong>麦克斯韦-玻尔兹曼分布</strong>。</p><p>在<u>中性流体</u>中，粒子之间的相互作用只发生在很小的尺度上。典型情景下粒子之间的作用力是范德瓦尔斯力，其大小随着距离快速下降；换句话说，典型散射截面的大小与粒子大小（也即原子的波尔半径）相当，对应的尺度很小。因此，粒子在两次高度局域化、大角度散射（也即<strong>碰撞</strong>）之间走直线是一个很好的近似。下图 (a) 就是这样的粒子轨迹。除非流体极度稀薄，多数中性流体是有碰撞的，也即<em>粒子的平均自由程比感兴趣的尺度小</em>，尽管在天体物理中并非如此。这种情况下，流体力学的标准方程可能不再有效。</p><p>在完全电离的等离子体中，粒子之间的相互作用是长程的库仑力（$F \propto r^{-2}$），所以粒子更容易在运动中逐渐偏转，而不是被碰撞改变方向，这对应着下图 (b) 的情况。</p><p>对于弱电离的等离子体，碰撞多发生在中性粒子和携带电荷的粒子之间。这样的碰撞是短程的，所以其行为更像一般的中性流体。</p><p>在天体物理中我们常常遇到相互作用由引力主导的情况。我们将这种流体称为 <u>N 体系统</u>。例如暗物质晕（如果暗物质包括 WIMP 或者轴子）和星系（恒星在其中作为中性粒子，相互作用为引力）。由于引力是长程的，系统中的每个粒子都会受到其他粒子的作用。现在考虑弛豫平衡系统中 $x_i$ 位置处的引力 $F_i$，我们有<br>$$<br>\vec{F}(t) = \lang\vec{F}\rang_i + \delta\vec{F}_i(t)<br>$$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>First Blog!</title>
      <link href="/2022/08/15/20220815/"/>
      <url>/2022/08/15/20220815/</url>
      
        <content type="html"><![CDATA[<p>Hello</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
